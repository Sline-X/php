https://w6p.ru/NmQ4NDg.png 

`\S` - любой не пробельный символ  
`\+` повтор один или более раз
`[]+` - любое число  
`/i` - регистронезависимый поиск  
`/s` - однострочный режим  
`/m` - многострочный режим  

В отличие от функции сопоставления, замена по умолчанию работает в однострочном режиме - как будто бы указан модификатор /s! Эта особенность может породить трудно обнаруживаемые ошибки для переменных, которые содержат символы перевода строки

Простые символы  
Управляющие символы (литералы)

Управляюще конструкции (квантификаторы повторений,
оператор альтернативы, группирующие скобки и т.д.);

Мнимые символы

Управляющие символы: .*+?|()[]{}$^ //все символы, кроме этих, обозначают в регулярном выражении сами себя и не имеют каких-либо специальных назначений

'/выражение/М', где М - модификаторы

Рекомендуется везде, где можно, использовать строки в апострофах, а не в кавычках. Дело в том, что символ $, являющийся специальным в регулярных выражениях, также обозначает переменную в PHP. Так что, если вы хотите, чтобы $ остался самим собой, а не был воспринят как переменная, используйте апострофы, либо же ставьте перед ним обратный слеш

Альтернативные ограничители
Можно использовать любые одинаковые символы как ограничители
'/path\\/to\\/file/i'
'#path/to/file#i'
'"path/to/file"i'

А можно парные скобки  
'{path/to/file}i'  
'[path/to/file]i'  
'(path/to/file)i'

парные скобки, встречающиеся внутри выражений, уже не нужно экранировать обратным слешем

В литературе и реальных проектах все же принято использовать / в качестве "ограничителей по умолчанию"

Классы символов:  
точка `.` - обозначает один любой символ
(выражение /a.b/s имеет совпадение для строк azb, aqb, но не для ab, aqwb)  
`\s` - соответствует пробельному символу(" "), знаку табуляции(\t), переносу строки(\n) или возврату каретки(\r)  
`\S` - любой символ, кроме пробельного  
`\w` - любая буква или цифра  
`\W` - не буква и не цифра  
`\d` - цифра от 0 до 9  
`\D` - всё что угодно, но только не цифра

Альтернативы  
`[:alnum:]` - буква или цифра  
`[:alpha:]` - буква  
`[:ascii:]` - символы с кодом 0-127  
`[:blank:]` - пробельный символ или символ табуляции  
`[:cnrtl:]` - управляющий символ  
`[:digit:]` - цифра  
`[:graph:]` - символ псевдографики  
`[:lower:]` - символ нижнего регистра  
`[:print:]` - печатаемый символ  
`[:punct:]` - знак пунктуации  
`[:space:]` - пробельный символ  
`[:upper:]` - символ верхнего регистра  
`[:word:]` - символы "слова" (аналог \w)  
`[:xdigit:]` - шестнадцатеричные цифры: число или буква от A до F  

`/abc[[:alnum:]]+/` #abc, затем одна или более буква, или цифра  
`/abc[[:alpha:][:punct:]0]/` #abc, далее буква, знак пунктуации или 0  
но совершенно не допустимо следующее  
`/abc[:alnum:]+/` - не будет работать

`/abc[\w.]/` - ищет подстроку abc, после которой идёт любая буква, цифра или точка  

Отрицание символов ^  
Пример: `[^<>]` - любой символ, кроме тех что указаны после ^
Все HTML теги в строке `/<[^>]+>/`

Этот способ хорош только для XML-файлов, для которых точно известно:
внутри тега не может содержаться символ >. В HTML же все несколько сложнее - например, в нем допустима
конструкция: <img src=".gif" alt="a>b">. Конечно, приведенное ранее регулярное выражение для неё 
сработает неверно (точно так же, как и стандартная функция PHP strip_tags())

Квантификаторы повторений  
Ноль или более совпадений `*`  
`/a-*-/` - соответствует строке, в которой буква a, затем - ноль или более минусов и, наконец, завершающий минус

Одно или более совпадений  
`/a--*/` - строки с a и одним или более минусом  
`/a-+/`

Пример:  
Есть ли в строке английское слово, написанное через дефис
`/[a-zA-Z]+-[a-zA-Z]+/`

Ноль или одно совпадение  
`?` - предыдущий символ может быть повторен ноль или один(но не более) раз

Например `/[a-zA-Z]+\r?\n/` - определяет строки, в которых последнее слово прижато к правому краю строки. Если мы работаем в UNIX, то в конце строки символ \r обычно отсутствует, тогда как в текстовых файлах Windows каждая строка заканчивается парой \r\n


Заданное число совпадений  
`X{n,m}` - указывает, что символ X может быть повторен от n до m раз  
`X{n}` - указывает, что символ X должен быть повторен ровно n раз  
`X{n,}` - указывает, что символ X может быть повторен n или более раз  

n и m находятся в диапазоне от 0 до 65 535


Мнимые символы  
участок строки между соседними символами, удовлетворяющий некоторым свойствам

`^` - соответствует началу строки (не первому символу, а в точности началу строки - позицию перед первым символом)

`$` - соответствует концу строки (позиции за концом строки)

`\b` - соответствует началу или концу слова. ФАктически любая позиция между `\w\W` или `\W\w` заставляет `\b` сработать

`\B` - любая позиция, кроме начала или конца слова

Примеры:  
`/^\w:/` - соответствует любой строке, начинающейся с буквы, завершенной двоеточием. Абсолютный путь в Windows выглядит именно таким образом  
`/\.txt$/i` - соответствует строке, хранящей имя файла с расширением txt  
`/^$/s` - сопоставимо только с пустой строкой, потому что говорит: "сразу после начала строки идёт её конец"  


Операторы альтернативы  
возможность задавать альтернативы не одиночных символов, а сразу их групп  
Это делается оператором |  
Примеры:  
`/1|2|3/` полностью эквивалентно выражению `/[123]/`, но сопоставление происходит несколько медленнее

выражению `/\.gif$|\.jpe&g$/` соответствуют имена файлов в формате GIF или JPEG

выражению `#^\w:|^////|^/#` (мы используем # в качестве ограничителей, чтобы не пришлось добавлять лишних "зубочисток", которых тут и так предостаточно) соответствуют только абсолютные файловые пути.
Действительно, его можно прочитать так: "в начале строки идёт либо буква диска, либо же прямой или обратный слеш"


Группирующие скобки  
Пример: `#^(\w:|\\\\|/)#`

Карманы  
`|^\s* ( (\d+) \s*[[:punct:]]\s* (\d+) \s*[[:punct:]]\s* (\d+)) \s*$|xs`  
в первый карман запишется дата, но уже без ведущих и концевых пробелов (это обеспечивает самая внешняя пара скобок)
во второй карман запишется лень  
в третий - месяц  
наконец, в четвертый - год  

Порядок нумерации карманов - она идёт по номеру открывающейся скобки, независимо от вложенности.

Получить содержимое карманов - список, который передаётся по ссылке функции preg_match() третьим параметром, и есть карманы

Модификатор /x - с его помощью мы можем игнорировать не только пробелы в выражениях, но и переводы строк.
Кроме того, можно писать комментарии, предваряя их решеткой #.

Карманы в функции замены
Нужно все слова в строке, начинающиеся с доллара $ сделать жирными
обрамить тегами <b></b>
Для обнаружения /\$[a-z]\w*/i.

Карманы в функции сопоставления
Можно задействовать содержимое карманов в функции preg_match() раньше, чем закончится сопоставление.
Управлять ходом поиска на основе данных в карманах. Это называется обратной ссылкой.
Пример:
Известно, что в строке есть подстрока, обрамленная какими-то HTML-тегами (например <b> или <pre>),
но неизвестно, какими. Требуется поместить эту подстроку в карман, чтобы в дальнейшем с ней работать.
Закрывающий тег должен соответствовать открывающему.
Задача решается с помощью такого регулярного выражения:
|<(w+) [^>]* > (.*?) </\1|>xs
Конструкция .*? обозначает не "любое минимальное число произвольных символов", заставляет звездочку 
"умерить аппетит" и совпасть не с максимально, а с минимально возможным числом символов.
Внутренний текст окажется во втором кармане, а имя тега - в первом.
Как это работает: PHP пытается найти открывающий тег и, как только находит, записывает его имя в первый карман (т.к. это имя обрамлено в выражении первой парой скобок).
Далее он смотрит вперед и, как только наталкивается на </, определяется, следует ли за ним то самое имя тега, которое
у него лежит в первом кармане. Это действие заставяет его предпринять конструкция \1, которая замещается на содержимое первого кармана каждый раз,
когда до неё доходит очередь. Если имя не совпадает, то такой вариант PHP отбрасывает и "идет" дальше, а иначе сигнализирует о совпадении.

Игнорирование карманов
Карманы нумеруются, начиная с индекса 1, причём карманом считается любое соответствие круглым скобкам.

Именованные карманы
Количество круглых скобок-карманов может быть довольно велико, и их игнорирование не всегда возможно, особенно при отладке регулярного выражения.
Поэтому для более удобного оперирования карманами введено их именование. Для этого после открывающейся круглой скобки указывается знак вопроса,
после которого в угловых скобках или апострофах задается имя кармана.


Жадность квантификаторов
Почему бы вместо .*? не написать просто .* 
см листинг 28.10
Выражение .* захватило максимально возможное число символов, а потому конец
выражения совпал не с парным тегом </b>, а с самым последним в строке.

Поставив знак вопроса после любого из квантификаторов *, +, {} или даже ?,
мы даем ему "таблетку от жадности". Как говорят в литературе по регулярным выражениям, мы 
делаем квантификатор "ленивым".
Выражения *?, +?, {}? и ?? следует воспринимать как цельные квантификаторы!
Это не составная конструкция, а именно одна управляющая последовательность.
Обычные "ленивые" квантификаторы применяют для поиска конструкций, претендующих
на роль парных. Например, следующий код удаляет все теги из некоторой строки
echo preg_replace('/<.+?>/s', '', $str);
// Выглядит явно изящнее, чем /<[^>]+>/s
Код для замены "псевдотегов" [b]...[/b] их HTML-эквивалентам мог бы выглядеть так:
echo preg_replace('|\[b\] (.*?) \[/b\]|ixs', '<b>$1</b>', $str);

