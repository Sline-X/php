https://w6p.ru/NmQ4NDg.png 

`\S` - любой не пробельный символ  
`\+` повтор один или более раз
`[]+` - любое число  
`/i` - регистронезависимый поиск  
`/s` - однострочный режим  
`/m` - многострочный режим  

В отличие от функции сопоставления, замена по умолчанию работает в однострочном режиме - как будто бы указан модификатор /s! Эта особенность может породить трудно обнаруживаемые ошибки для переменных, которые содержат символы перевода строки

Простые символы  
Управляющие символы (литералы)

Управляюще конструкции (квантификаторы повторений,
оператор альтернативы, группирующие скобки и т.д.);

Мнимые символы

Управляющие символы: .*+?|()[]{}$^ //все символы, кроме этих, обозначают в регулярном выражении сами себя и не имеют каких-либо специальных назначений

'/выражение/М', где М - модификаторы

Рекомендуется везде, где можно, использовать строки в апострофах, а не в кавычках. Дело в том, что символ $, являющийся специальным в регулярных выражениях, также обозначает переменную в PHP. Так что, если вы хотите, чтобы $ остался самим собой, а не был воспринят как переменная, используйте апострофы, либо же ставьте перед ним обратный слеш

Альтернативные ограничители
Можно использовать любые одинаковые символы как ограничители
'/path\\/to\\/file/i'
'#path/to/file#i'
'"path/to/file"i'

А можно парные скобки  
'{path/to/file}i'  
'[path/to/file]i'  
'(path/to/file)i'

парные скобки, встречающиеся внутри выражений, уже не нужно экранировать обратным слешем

В литературе и реальных проектах все же принято использовать / в качестве "ограничителей по умолчанию"

Классы символов:  
точка `.` - обозначает один любой символ
(выражение /a.b/s имеет совпадение для строк azb, aqb, но не для ab, aqwb)  
`\s` - соответствует пробельному символу(" "), знаку табуляции(\t), переносу строки(\n) или возврату каретки(\r)  
`\S` - любой символ, кроме пробельного  
`\w` - любая буква или цифра  
`\W` - не буква и не цифра  
`\d` - цифра от 0 до 9  
`\D` - всё что угодно, но только не цифра

Альтернативы  
`[:alnum:]` - буква или цифра  
`[:alpha:]` - буква  
`[:ascii:]` - символы с кодом 0-127  
`[:blank:]` - пробельный символ или символ табуляции  
`[:cnrtl:]` - управляющий символ  
`[:digit:]` - цифра  
`[:graph:]` - символ псевдографики  
`[:lower:]` - символ нижнего регистра  
`[:print:]` - печатаемый символ  
`[:punct:]` - знак пунктуации  
`[:space:]` - пробельный символ  
`[:upper:]` - символ верхнего регистра  
`[:word:]` - символы "слова" (аналог \w)  
`[:xdigit:]` - шестнадцатеричные цифры: число или буква от A до F  

`/abc[[:alnum:]]+/` #abc, затем одна или более буква, или цифра  
`/abc[[:alpha:][:punct:]0]/` #abc, далее буква, знак пунктуации или 0  
но совершенно не допустимо следующее  
`/abc[:alnum:]+/` - не будет работать

`/abc[\w.]/` - ищет подстроку abc, после которой идёт любая буква, цифра или точка  

Отрицание символов ^  
Пример: `[^<>]` - любой символ, кроме тех что указаны после ^
Все HTML теги в строке `/<[^>]+>/`

Этот способ хорош только для XML-файлов, для которых точно известно:
внутри тега не может содержаться символ >. В HTML же все несколько сложнее - например, в нем допустима
конструкция: <img src=".gif" alt="a>b">. Конечно, приведенное ранее регулярное выражение для неё 
сработает неверно (точно так же, как и стандартная функция PHP strip_tags())

Квантификаторы повторений  
Ноль или более совпадений `*`  
`/a-*-/` - соответствует строке, в которой буква a, затем - ноль или более минусов и, наконец, завершающий минус

Одно или более совпадений  
`/a--*/` - строки с a и одним или более минусом  
`/a-+/`

Пример:  
Есть ли в строке английское слово, написанное через дефис
`/[a-zA-Z]+-[a-zA-Z]+/`

Ноль или одно совпадение  
`?` - предыдущий символ может быть повторен ноль или один(но не более) раз

Например `/[a-zA-Z]+\r?\n/` - определяет строки, в которых последнее слово прижато к правому краю строки. Если мы работаем в UNIX, то в конце строки символ \r обычно отсутствует, тогда как в текстовых файлах Windows каждая строка заканчивается парой \r\n


Заданное число совпадений  
`X{n,m}` - указывает, что символ X может быть повторен от n до m раз  
`X{n}` - указывает, что символ X должен быть повторен ровно n раз  
`X{n,}` - указывает, что символ X может быть повторен n или более раз  

n и m находятся в диапазоне от 0 до 65 535


Мнимые символы  
участок строки между соседними символами, удовлетворяющий некоторым свойствам

`^` - соответствует началу строки (не первому символу, а в точности началу строки - позицию перед первым символом)

`$` - соответствует концу строки (позиции за концом строки)

`\b` - соответствует началу или концу слова. ФАктически любая позиция между `\w\W` или `\W\w` заставляет `\b` сработать

`\B` - любая позиция, кроме начала или конца слова

Примеры:  
`/^\w:/` - соответствует любой строке, начинающейся с буквы, завершенной двоеточием. Абсолютный путь в Windows выглядит именно таким образом  
`/\.txt$/i` - соответствует строке, хранящей имя файла с расширением txt  
`/^$/s` - сопоставимо только с пустой строкой, потому что говорит: "сразу после начала строки идёт её конец"  


Операторы альтернативы  
возможность задавать альтернативы не одиночных символов, а сразу их групп  
Это делается оператором |  
Примеры:  
`/1|2|3/` полностью эквивалентно выражению `/[123]/`, но сопоставление происходит несколько медленнее

выражению `/\.gif$|\.jpe&g$/` соответствуют имена файлов в формате GIF или JPEG

выражению `#^\w:|^////|^/#` (мы используем # в качестве ограничителей, чтобы не пришлось добавлять лишних "зубочисток", которых тут и так предостаточно) соответствуют только абсолютные файловые пути.
Действительно, его можно прочитать так: "в начале строки идёт либо буква диска, либо же прямой или обратный слеш"


Группирующие скобки  
Пример: `#^(\w:|\\\\|/)#`

Карманы  
`|^\s* ( (\d+) \s*[[:punct:]]\s* (\d+) \s*[[:punct:]]\s* (\d+)) \s*$|xs`  
в первый карман запишется дата, но уже без ведущих и концевых пробелов (это обеспечивает самая внешняя пара скобок)
во второй карман запишется лень  
в третий - месяц  
наконец, в четвертый - год  

Порядок нумерации карманов - она идёт по номеру открывающейся скобки, независимо от вложенности.

Получить содержимое карманов - список, который передаётся по ссылке функции preg_match() третьим параметром, и есть карманы

Модификатор /x - с его помощью мы можем игнорировать не только пробелы в выражениях, но и переводы строк.
Кроме того, можно писать комментарии, предваряя их решеткой #.

Карманы в функции замены

